---
plan: 02-05
title: Set Up Revalidation Webhook
phase: 2
wave: 3
depends_on:
  - 02-01
  - 02-02
  - 02-03
  - 02-04
files_modified:
  - app/api/revalidate/route.ts
  - .env.local
autonomous: false
---

# Plan 02-05: Set Up Revalidation Webhook

## Objective
Configure on-demand revalidation so that content changes in Sanity Studio are reflected on the live site within seconds, using Next.js tag-based revalidation triggered by Sanity webhooks.

## must_haves
- API route at `/api/revalidate` to receive webhook calls
- Webhook signature validation for security
- Tag-based revalidation by document type
- Revalidation secret configured in both Sanity and Vercel
- Webhook configured in Sanity dashboard
- Fallback time-based revalidation as safety net

## Tasks

<task id="1">
**Generate revalidation secret**

Generate a secure random secret for webhook validation:

```bash
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

Save this value - you'll need it for both `.env.local` and Sanity webhook configuration.
</task>

<task id="2" depends_on="1">
**Add secret to environment variables**

Add to `.env.local`:

```env
# Existing variables
NEXT_PUBLIC_SANITY_PROJECT_ID=your_project_id
NEXT_PUBLIC_SANITY_DATASET=production

# New: Revalidation webhook secret
SANITY_REVALIDATE_SECRET=your_generated_secret_here
```

**IMPORTANT:** Also add this to Vercel environment variables for production:
1. Go to Vercel dashboard > Project > Settings > Environment Variables
2. Add `SANITY_REVALIDATE_SECRET` with the same value
3. Set for Production, Preview, and Development environments
</task>

<task id="3" depends_on="2">
**Create revalidation API route**

Create `app/api/revalidate/route.ts`:

```typescript
import { revalidateTag } from 'next/cache'
import { type NextRequest, NextResponse } from 'next/server'
import { parseBody } from 'next-sanity/webhook'

// Webhook payload type
type WebhookPayload = {
  _type: string
  _id: string
  slug?: { current: string }
}

export async function POST(req: NextRequest) {
  try {
    // Validate webhook signature
    const { isValidSignature, body } = await parseBody<WebhookPayload>(
      req,
      process.env.SANITY_REVALIDATE_SECRET
    )

    if (!isValidSignature) {
      return NextResponse.json(
        { message: 'Invalid signature', revalidated: false },
        { status: 401 }
      )
    }

    if (!body?._type) {
      return NextResponse.json(
        { message: 'Bad request: missing _type', revalidated: false },
        { status: 400 }
      )
    }

    // Revalidate based on document type
    const revalidatedTags: string[] = []

    // Always revalidate the document type tag
    revalidateTag(body._type)
    revalidatedTags.push(body._type)

    // Type-specific revalidation
    switch (body._type) {
      case 'siteSettings':
        // Site settings affect all pages (header, footer, etc.)
        revalidateTag('site')
        revalidatedTags.push('site')
        break

      case 'page':
        // Revalidate specific page by slug
        if (body.slug?.current) {
          revalidateTag(`page-${body.slug.current}`)
          revalidatedTags.push(`page-${body.slug.current}`)
        }
        // Also revalidate navigation/page lists
        revalidateTag('pages')
        revalidatedTags.push('pages')
        break

      case 'teamMember':
        // Revalidate team sections
        revalidateTag('team')
        revalidatedTags.push('team')
        break
    }

    console.log(`[Revalidate] Type: ${body._type}, Tags: ${revalidatedTags.join(', ')}`)

    return NextResponse.json({
      revalidated: true,
      now: Date.now(),
      type: body._type,
      tags: revalidatedTags,
    })
  } catch (err) {
    console.error('[Revalidate] Error:', err)
    return NextResponse.json(
      { message: 'Error revalidating', revalidated: false },
      { status: 500 }
    )
  }
}

// Sanity only sends POST requests for webhooks
export async function GET() {
  return NextResponse.json(
    { message: 'Method not allowed. This endpoint only accepts POST requests from Sanity webhooks.' },
    { status: 405 }
  )
}
```

This handles:
- Signature validation (rejects unsigned requests)
- Type-based tag revalidation
- Slug-specific revalidation for pages
- Logging for debugging
</task>

<task id="4" depends_on="3">
**Configure webhook in Sanity**

**USER ACTION REQUIRED:** Set up the webhook in Sanity dashboard:

1. Go to `sanity.io/manage` > Your Project > API > Webhooks
2. Click "Create webhook"
3. Configure:
   - **Name:** `Next.js Revalidation`
   - **URL:** `https://koorfameus.vercel.app/api/revalidate`
   - **Dataset:** `production`
   - **Trigger on:** Create, Update, Delete (all three)
   - **Filter:** Leave empty (triggers on all document types)
   - **Projection:** `{_type, _id, slug}`
   - **Status:** Enabled
   - **HTTP method:** POST
   - **HTTP headers:** None needed
   - **Secret:** Paste the same secret from step 1

4. Click "Save"

For local testing, you can temporarily use a tool like ngrok to expose localhost:
```bash
ngrok http 3000
```
Then use the ngrok URL as the webhook URL temporarily.
</task>

<task id="5" depends_on="4">
**Update queries to use cache tags**

When fetching data in pages, include cache tags for revalidation.

Example for a page fetching site settings:

```typescript
// app/page.tsx (example)
import { client } from '@/sanity/lib/client'
import { siteSettingsQuery } from '@/sanity/lib/queries'

export default async function HomePage() {
  const settings = await client.fetch(
    siteSettingsQuery,
    {},
    {
      next: {
        tags: ['siteSettings', 'site'],
        revalidate: 3600, // Fallback: revalidate every hour
      },
    }
  )

  return (
    <main>
      <h1>{settings?.siteName ?? 'KoorFameus'}</h1>
    </main>
  )
}
```

Tag conventions:
- `siteSettings` - Site settings document
- `site` - Anything that affects all pages
- `page` - All page documents
- `page-{slug}` - Specific page by slug
- `pages` - Page listings/navigation
- `teamMember` - All team members
- `team` - Team sections
</task>

<task id="6" depends_on="5">
**Test revalidation locally**

1. Start the dev server:
   ```bash
   npm run dev
   ```

2. Test the API route manually:
   ```bash
   curl -X POST http://localhost:3000/api/revalidate \
     -H "Content-Type: application/json" \
     -d '{"_type": "siteSettings", "_id": "siteSettings"}'
   ```

   Expected response (without valid signature):
   ```json
   {"message":"Invalid signature","revalidated":false}
   ```

3. For full testing, deploy to Vercel and test with actual Sanity webhook.
</task>

<task id="7" depends_on="6">
**Test end-to-end revalidation**

After deploying to Vercel:

1. Open the production site in a browser
2. Open Sanity Studio at `/studio`
3. Make a change to siteSettings (e.g., change siteName)
4. Publish the change
5. Refresh the production site within a few seconds
6. Content should reflect the new value

Check Vercel logs (Vercel dashboard > Deployments > Functions) for revalidation logs.
</task>

## Verification

1. **API route exists:**
   - `app/api/revalidate/route.ts` exists
   - Route handles POST requests

2. **Environment variable:**
   - `.env.local` contains `SANITY_REVALIDATE_SECRET`
   - Vercel environment variables include the same secret

3. **Security:**
   - Unsigned requests return 401
   - Invalid payloads return 400
   - Only POST method is allowed (GET returns 405)

4. **Webhook configuration:**
   - Webhook visible in Sanity dashboard
   - Correct URL pointing to production
   - Triggers on Create, Update, Delete
   - Projection includes `{_type, _id, slug}`

5. **End-to-end test:**
   - Edit content in Studio
   - Publish
   - Site updates within 5-10 seconds
   - Vercel logs show successful revalidation

6. **Fallback:**
   - Even without webhook trigger, pages revalidate after time-based interval (3600s default)
